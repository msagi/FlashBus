/*
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 *
 * This class was automatically generated by the FlashBusGenerator from the FlashBus
 * annotation data it found. It should not be edited becuase the changes will be lost
 * when sources are regenerated.
 */

/*
 * Copyright 2015 Miklos Sagi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
{Package}
import android.content.Context;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.util.Log;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;

{Imports}
/**
 * Custom generated event bus of FlashBus.
 *
 * Guide:
 * Annotations in anonymous classes are invisible to annotation processing that is why this event bus does not support event handlers in anonymous classes.
 *
 * @author msagi (miklos.sagi@gmail.com)
 * @see com.msagi.flashbus.annotation.AnnotationProcessor
 * @see com.msagi.flashbus.annotation.Subscribe
 */
public class FlashBus {

    /**
     * Generic dispatcher base class. Implements runnable to be able to post it to a Handler.
     *
     * @param <T1> Type of the subscriber class.
     * @param <T2> Type of the event class.
     */
    private abstract static class Dispatcher<T1, T2> implements Runnable {

        /**
         * Event queue (the dispatcher is able to dispatch in batch in case of frequent event production).
         */
        protected ConcurrentLinkedQueue<T2> mEventQueue = new ConcurrentLinkedQueue<>();

        /**
         * Thread safe flag to track if the dispatching is active.
         */
        protected AtomicBoolean mIsDispatchingActive = new AtomicBoolean(false);

        /**
         * The target handler to event to be dispatched on.
         */
        protected Handler mHandler;

        /**
         * The instance of the subscriber class.
         */
        protected T1 mSubscriber;

        /**
         * Create new instance (it does not use Android annotation @NonNull to avoid necessary dependency).
         *
         * @param subscriber The subscriber instance.
         * @param handler    The handler instance.
         */
        public Dispatcher(final T1 subscriber, final Handler handler) {
            if (subscriber == null) {
                throw new IllegalArgumentException("subscriber == null");
            }
            mSubscriber = subscriber;
            if (handler == null) {
                throw new IllegalArgumentException("handler == null");
            }
            mHandler = handler;
        }

        /**
         * Dispatch event instance.
         *
         * @param event The event instance to be dispatched.
         */
        public void dispatch(final T2 event) {
            mEventQueue.add(event);
            if (mIsDispatchingActive.compareAndSet(/* expected value */ false, /* new value */ true)) {
                mHandler.post(this);
            }
        }

        /**
         * The actual implementation of the event delivery (needs to be custom generated because of speed considerations).
         */
        public abstract void run();
    }

    /**
     * Tag for logging.
     */
    private static final String TAG = FlashBus.class.getSimpleName();

    /**
     * The default (singleton) event bus instance.
     */
    private static FlashBus sInstance;

    /**
     * The application context for the bus instance.
     */
    private static Context sApplicationContext;

    /**
     * The initial capacity of the event dispatcher lists.
     */
    private static final int EVENT_DISPATCHER_LIST_INITIAL_CAPACITY = 8;

    /**
     * The debug flag for the bus instance.
     */
    private static final boolean DEBUG = {Debug};

    /**
     * Handler for main thread.
     */
    private final Handler MAIN_HANDLER = new Handler(Looper.getMainLooper());

    /**
     * Handler for background thread.
     */
    private final Handler BACKGROUND_HANDLER;

    /**
     * The map of sticky events.
     */
    private final ConcurrentHashMap<Class, Object> mStickyEvents = new ConcurrentHashMap<>();

    /**
     * Create new event bus instance.
     *
     * @param base The base context.
     */
    public FlashBus() {
        final HandlerThread backgroundHandlerThread = new HandlerThread("backgroundHandler[flashBus:" + hashCode() + "]");
        backgroundHandlerThread.start();
        BACKGROUND_HANDLER = new Handler(backgroundHandlerThread.getLooper());
    }

    /**
     * Set the application contect to the bus.
     *
     * @param context The application context.
     */
    public static void setApplicationContext(final Context context) {
        sApplicationContext = context;
    }

    /**
     * Get default instance.
     *
     * @return The default event bus instance.
     */
    public synchronized static FlashBus getDefault() {
        if (sInstance == null) {
            if (DEBUG) {
                Log.d(TAG, "Initializing...");
            }
            if (sApplicationContext != null) {
                final String flashBusClassName = sApplicationContext.getPackageName() + ".FlashBus";
                try {
                    if (DEBUG) {
                        Log.d(TAG, "Trying to load [" + flashBusClassName + "]...");
                    }
                    //try to load the flash bus for the application project
                    final Class flashBusClass = Class.forName(flashBusClassName);
                    sInstance = (FlashBus) flashBusClass.newInstance();
                    if (DEBUG) {
                        Log.d(TAG, "FlashBus loaded: [" + flashBusClassName + "]");
                    }
                    return sInstance;
                } catch (Exception e) {
                    //fall back to this FlashBus as application project may be not depend on FlashBus
                    if (DEBUG) {
                        Log.d(TAG, "Failed to load [" + flashBusClassName + "]...");
                    }
                }
            }

            if (DEBUG) {
                Log.d(TAG, "Falling back to default FlashBus [" + FlashBus.class.getName() + "]...");
            }

            //there may be a flat FlashBus architecture application
            sInstance = new FlashBus();
        }

        return sInstance;
    }

    /**
     * Register subscriber instance to the bus. (This method is a placeholder before custom method generation)
     *
     * @param subscriber The subscriber instance to register.
     */
    public void register(final Object subscriber) {
        Log.e(TAG, String.format("Subscriber object registered without custom .register() implementation: subscriber %s", subscriber));
    }

    /**
     * Unregister subscriber instance from the bus.  (This method is a placeholder before custom method generation)
     *
     * @param subscriber The subscriber instance to unregister.
     */
    public void unregister(final Object subscriber) {
        Log.e(TAG, String.format("Subscriber object unregistering without custom .unregister() implementation: subscriber %s", subscriber));
    }

    /**
     * Post an event to the bus. (This method is a placeholder before custom method generation)
     *
     * @param event The event instance to be posted.
     */
    public void post(final Object event) {
        Log.e(TAG, String.format("Event produced without subscriber implementation: event %s", event));
    }

    /**
     * Post a sticky event to the bus. (This method is a placeholder before custom method generation)
     *
     * @param event The event instance to be posted.
     */
    public void postSticky(final Object event) {
        Log.e(TAG, String.format("Event produced without subscriber implementation: event %s", event));
    }

    /**
     * Get a sticky event from the bus.
     *
     * @param eventClass The event class the sticky event instance to be returned.
     * @return The sticky event instance if any, null otherwise.
     */
    public <T> T getStickyEvent(final Class<T> eventClass) {
        if (eventClass == null) {
            return null;
        }
        return eventClass.cast(mStickyEvents.get(eventClass));
    }

    /**
     * Remove a sticky event from the bus. (This method is a placeholder before custom method generation)
     *
     * @param eventClass The event class the sticky event instance to be removed.
     */
    public void removeStickyEvent(final Class eventClass) {
        if (eventClass == null) {
            return;
        }
        mStickyEvents.remove(eventClass);
    }

    //
    // Custom generated code
    //
{InnerClasses}
{Fields}
{Methods}
}